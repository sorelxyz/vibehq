# PRD: VibeHq

## Overview

VibeHq is a local ticket management system for orchestrating multiple RALPH (autonomous AI coding) instances. It provides a drag-and-drop kanban board to manage tickets through their lifecycle: creating tickets, generating PRDs via Claude Code, launching parallel RALPH executions in isolated git worktrees, and tracking progress with real-time log tailing.

**Tech Stack:**
- **Frontend:** React + Vite + TypeScript + TailwindCSS
- **Backend:** Bun + Hono + Drizzle ORM
- **Database:** SQLite with WAL mode
- **Real-time:** Bun native WebSocket
- **Drag-and-drop:** @dnd-kit/core

**Architecture Principles:**
- Separation of concerns: Database layer → Service layer → API layer → Frontend
- Shared types between frontend and backend via workspace package
- All business logic in service layer, not in API handlers
- Frontend uses TanStack Query for server state management

---

## Items

### 1. Project Scaffolding and Monorepo Setup

Create the monorepo structure with Bun workspaces.

**Files to create:**

```
vibehq/
├── package.json                 # Root workspace config
├── tsconfig.base.json           # Shared TypeScript config
├── .gitignore                   # Git ignores
├── apps/
│   ├── web/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── vite.config.ts
│   │   ├── index.html
│   │   ├── tailwind.config.js
│   │   ├── postcss.config.js
│   │   └── src/
│   │       ├── main.tsx
│   │       ├── App.tsx
│   │       └── index.css
│   └── server/
│       ├── package.json
│       ├── tsconfig.json
│       └── src/
│           └── index.ts
└── packages/
    └── shared/
        ├── package.json
        ├── tsconfig.json
        └── src/
            └── index.ts
```

**Root package.json:**
```json
{
  "name": "vibehq",
  "private": true,
  "workspaces": ["apps/*", "packages/*"],
  "scripts": {
    "dev": "bun run --parallel dev:web dev:server",
    "dev:web": "bun run --filter @vibehq/web dev",
    "dev:server": "bun run --filter @vibehq/server dev"
  }
}
```

**apps/web package.json name:** `@vibehq/web`

**apps/web dependencies:**
- react, react-dom, react-router-dom
- @tanstack/react-query
- @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities
- tailwindcss, postcss, autoprefixer
- vite, @vitejs/plugin-react
- typescript, @types/react, @types/react-dom
- @vibehq/shared (workspace:*)

**apps/server package.json name:** `@vibehq/server`

**apps/server dependencies:**
- hono
- drizzle-orm
- nanoid (for generating IDs)
- @vibehq/shared (workspace:*)

**packages/shared package.json name:** `@vibehq/shared`
- Export TypeScript types/interfaces only
- No runtime dependencies

**Vite config:**
- Proxy `/api` requests to `http://localhost:3001`
- Proxy `/uploads` requests to `http://localhost:3001`

**Server index.ts:**
- Basic Hono server on port 3001
- Console log "Server running on http://localhost:3001"

**Acceptance Criteria:**
- [ ] Running `bun install` at root installs all workspace dependencies
- [ ] Running `bun run dev:web` starts Vite dev server on port 5173
- [ ] Running `bun run dev:server` starts Hono server on port 3001
- [ ] TypeScript compiles without errors in all workspaces
- [ ] Shared package can be imported in both web and server
- [ ] Vite proxies /api requests to server

### 2. Database Schema with Drizzle ORM

Define the complete database schema upfront using Drizzle ORM.

**File:** `apps/server/src/db/schema.ts`

```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';

// projects - Codebases that can have tickets
export const projects = sqliteTable('projects', {
  id: text('id').primaryKey(), // nanoid
  name: text('name').notNull(),
  path: text('path').notNull(), // Local filesystem path to codebase
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

// tickets - Work items that go through the kanban workflow
export const tickets = sqliteTable('tickets', {
  id: text('id').primaryKey(), // nanoid
  projectId: text('project_id').notNull().references(() => projects.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  description: text('description').notNull(),
  status: text('status', {
    enum: ['backlog', 'up_next', 'in_review', 'in_progress', 'in_testing', 'completed']
  }).notNull().default('backlog'),
  prdContent: text('prd_content'), // Generated PRD markdown
  branchName: text('branch_name'), // Git branch for this ticket
  position: integer('position').notNull().default(0), // Order within status column
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

// ticket_images - Attached images for tickets
export const ticketImages = sqliteTable('ticket_images', {
  id: text('id').primaryKey(), // nanoid
  ticketId: text('ticket_id').notNull().references(() => tickets.id, { onDelete: 'cascade' }),
  filename: text('filename').notNull(), // Original filename
  storagePath: text('storage_path').notNull(), // Path in uploads folder
  mimeType: text('mime_type').notNull(),
  size: integer('size').notNull(), // File size in bytes
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});

// ralph_instances - Running or completed RALPH executions
export const ralphInstances = sqliteTable('ralph_instances', {
  id: text('id').primaryKey(), // nanoid
  ticketId: text('ticket_id').notNull().references(() => tickets.id, { onDelete: 'cascade' }),
  status: text('status', {
    enum: ['pending', 'running', 'completed', 'failed']
  }).notNull().default('pending'),
  worktreePath: text('worktree_path'), // Path to git worktree
  logPath: text('log_path'), // Path to log file
  prdFilePath: text('prd_file_path'), // Path to generated PRD file
  scriptPath: text('script_path'), // Path to RALPH bash script
  pid: integer('pid'), // Process ID when running
  exitCode: integer('exit_code'), // Exit code when completed
  startedAt: integer('started_at', { mode: 'timestamp' }),
  completedAt: integer('completed_at', { mode: 'timestamp' }),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
});
```

**File:** `apps/server/src/db/index.ts`

```typescript
import { Database } from 'bun:sqlite';
import { drizzle } from 'drizzle-orm/bun-sqlite';
import * as schema from './schema';

// Create data directory if not exists
import { mkdirSync } from 'fs';
mkdirSync('./data', { recursive: true });

// Create database with WAL mode
const sqlite = new Database('./data/vibehq.db');
sqlite.run('PRAGMA journal_mode = WAL');
sqlite.run('PRAGMA foreign_keys = ON');

export const db = drizzle(sqlite, { schema });

// Export schema for use elsewhere
export * from './schema';
```

**File:** `apps/server/src/db/migrate.ts`
- Create all tables if they don't exist
- Use `CREATE TABLE IF NOT EXISTS` statements
- Run on server startup

**File:** `packages/shared/src/types.ts`

```typescript
// Status enums
export const TICKET_STATUSES = ['backlog', 'up_next', 'in_review', 'in_progress', 'in_testing', 'completed'] as const;
export type TicketStatus = typeof TICKET_STATUSES[number];

export const RALPH_STATUSES = ['pending', 'running', 'completed', 'failed'] as const;
export type RalphStatus = typeof RALPH_STATUSES[number];

// Entity types
export interface Project {
  id: string;
  name: string;
  path: string;
  createdAt: Date;
}

export interface Ticket {
  id: string;
  projectId: string;
  title: string;
  description: string;
  status: TicketStatus;
  prdContent: string | null;
  branchName: string | null;
  position: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface TicketImage {
  id: string;
  ticketId: string;
  filename: string;
  storagePath: string;
  mimeType: string;
  size: number;
  createdAt: Date;
}

export interface RalphInstance {
  id: string;
  ticketId: string;
  status: RalphStatus;
  worktreePath: string | null;
  logPath: string | null;
  prdFilePath: string | null;
  scriptPath: string | null;
  pid: number | null;
  exitCode: number | null;
  startedAt: Date | null;
  completedAt: Date | null;
  createdAt: Date;
}

// API types
export interface CreateProjectInput {
  name: string;
  path: string;
}

export interface UpdateProjectInput {
  name?: string;
  path?: string;
}

export interface CreateTicketInput {
  projectId: string;
  title: string;
  description: string;
}

export interface UpdateTicketInput {
  title?: string;
  description?: string;
  status?: TicketStatus;
  prdContent?: string;
  position?: number;
}

export interface ReorderTicketsInput {
  updates: Array<{ id: string; status: TicketStatus; position: number }>;
}
```

**Acceptance Criteria:**
- [ ] Database file created at `apps/server/data/vibehq.db`
- [ ] All tables created on server startup
- [ ] WAL mode enabled (verify with `PRAGMA journal_mode`)
- [ ] Foreign keys enabled
- [ ] Types exported from shared package match schema exactly
- [ ] Types can be imported in both web and server apps

### 3. Backend API - Projects CRUD

Implement the projects API endpoints using Hono with a service layer.

**File:** `apps/server/src/services/projects.ts`

```typescript
import { db, projects } from '../db';
import { eq } from 'drizzle-orm';
import { nanoid } from 'nanoid';
import type { Project, CreateProjectInput, UpdateProjectInput } from '@vibehq/shared';

export async function listProjects(): Promise<Project[]>
export async function getProject(id: string): Promise<Project | null>
export async function createProject(data: CreateProjectInput): Promise<Project>
export async function updateProject(id: string, data: UpdateProjectInput): Promise<Project>
export async function deleteProject(id: string): Promise<void>
```

**Service Logic:**
- `listProjects`: Select all, order by createdAt desc
- `getProject`: Select where id equals, return null if not found
- `createProject`: Generate nanoid, insert, return created record
- `updateProject`: Update where id equals, throw if not found, return updated
- `deleteProject`: Delete where id equals (cascade deletes tickets)

**File:** `apps/server/src/routes/projects.ts`

```typescript
import { Hono } from 'hono';
import * as projectsService from '../services/projects';

const app = new Hono();

// GET /api/projects - List all projects
app.get('/', async (c) => {
  const projects = await projectsService.listProjects();
  return c.json(projects);
});

// GET /api/projects/:id - Get single project
app.get('/:id', async (c) => {
  const project = await projectsService.getProject(c.req.param('id'));
  if (!project) return c.json({ error: 'Project not found' }, 404);
  return c.json(project);
});

// POST /api/projects - Create project
app.post('/', async (c) => {
  const body = await c.req.json();
  // Validate: name and path required
  if (!body.name || !body.path) {
    return c.json({ error: 'name and path are required' }, 400);
  }
  const project = await projectsService.createProject(body);
  return c.json(project, 201);
});

// PATCH /api/projects/:id - Update project
app.patch('/:id', async (c) => {
  const body = await c.req.json();
  try {
    const project = await projectsService.updateProject(c.req.param('id'), body);
    return c.json(project);
  } catch (e) {
    return c.json({ error: 'Project not found' }, 404);
  }
});

// DELETE /api/projects/:id - Delete project
app.delete('/:id', async (c) => {
  await projectsService.deleteProject(c.req.param('id'));
  return c.json({ success: true });
});

export default app;
```

**File:** `apps/server/src/index.ts` (update)

```typescript
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import projectsRoutes from './routes/projects';
import { migrate } from './db/migrate';

const app = new Hono();

// Run migrations on startup
migrate();

// Middleware
app.use('/api/*', cors({ origin: 'http://localhost:5173' }));

// Routes
app.route('/api/projects', projectsRoutes);

// Health check
app.get('/health', (c) => c.json({ status: 'ok' }));

export default {
  port: 3001,
  fetch: app.fetch,
};

console.log('Server running on http://localhost:3001');
```

**Acceptance Criteria:**
- [ ] GET /api/projects returns array of projects
- [ ] GET /api/projects/:id returns single project or 404
- [ ] POST /api/projects creates project, returns 201
- [ ] PATCH /api/projects/:id updates project
- [ ] DELETE /api/projects/:id deletes project and its tickets
- [ ] CORS allows requests from localhost:5173
- [ ] Validation returns 400 for missing required fields

### 4. Backend API - Tickets CRUD

Implement the tickets API endpoints with status management and reordering.

**File:** `apps/server/src/services/tickets.ts`

```typescript
import { db, tickets } from '../db';
import { eq, desc, and, sql } from 'drizzle-orm';
import { nanoid } from 'nanoid';
import type { Ticket, TicketStatus, CreateTicketInput, UpdateTicketInput } from '@vibehq/shared';

export async function listTickets(projectId?: string): Promise<Ticket[]>
export async function getTicket(id: string): Promise<Ticket | null>
export async function createTicket(data: CreateTicketInput): Promise<Ticket>
export async function updateTicket(id: string, data: UpdateTicketInput): Promise<Ticket>
export async function deleteTicket(id: string): Promise<void>
export async function updateTicketStatus(id: string, status: TicketStatus, position: number): Promise<Ticket>
export async function reorderTickets(updates: Array<{ id: string; status: TicketStatus; position: number }>): Promise<void>
export async function getNextPosition(status: TicketStatus): Promise<number>
```

**Service Logic:**

- `listTickets`: Select all (optionally filtered by projectId), order by status then position
- `getTicket`: Select where id equals, return null if not found
- `createTicket`:
  - Generate nanoid
  - Set status to 'backlog'
  - Set position to next available in backlog column
  - Set createdAt and updatedAt to now
  - Insert and return
- `updateTicket`: Update fields, set updatedAt to now
- `deleteTicket`: Delete where id equals
- `updateTicketStatus`: Update status and position, set updatedAt
- `reorderTickets`: Use transaction to update multiple tickets atomically
- `getNextPosition`: `SELECT MAX(position) + 1 FROM tickets WHERE status = ?`

**File:** `apps/server/src/routes/tickets.ts`

```typescript
import { Hono } from 'hono';
import * as ticketsService from '../services/tickets';

const app = new Hono();

// GET /api/tickets - List tickets (optional ?projectId filter)
app.get('/', async (c) => {
  const projectId = c.req.query('projectId');
  const tickets = await ticketsService.listTickets(projectId || undefined);
  return c.json(tickets);
});

// GET /api/tickets/:id - Get single ticket
app.get('/:id', async (c) => {
  const ticket = await ticketsService.getTicket(c.req.param('id'));
  if (!ticket) return c.json({ error: 'Ticket not found' }, 404);
  return c.json(ticket);
});

// POST /api/tickets - Create ticket
app.post('/', async (c) => {
  const body = await c.req.json();
  if (!body.projectId || !body.title || !body.description) {
    return c.json({ error: 'projectId, title, and description are required' }, 400);
  }
  const ticket = await ticketsService.createTicket(body);
  return c.json(ticket, 201);
});

// PATCH /api/tickets/:id - Update ticket
app.patch('/:id', async (c) => {
  const body = await c.req.json();
  try {
    const ticket = await ticketsService.updateTicket(c.req.param('id'), body);
    return c.json(ticket);
  } catch (e) {
    return c.json({ error: 'Ticket not found' }, 404);
  }
});

// DELETE /api/tickets/:id - Delete ticket
app.delete('/:id', async (c) => {
  await ticketsService.deleteTicket(c.req.param('id'));
  return c.json({ success: true });
});

// PATCH /api/tickets/:id/status - Update status and position (for drag-drop)
app.patch('/:id/status', async (c) => {
  const body = await c.req.json();
  if (!body.status || body.position === undefined) {
    return c.json({ error: 'status and position are required' }, 400);
  }
  const ticket = await ticketsService.updateTicketStatus(
    c.req.param('id'),
    body.status,
    body.position
  );
  return c.json(ticket);
});

// POST /api/tickets/reorder - Batch reorder tickets
app.post('/reorder', async (c) => {
  const body = await c.req.json();
  if (!body.updates || !Array.isArray(body.updates)) {
    return c.json({ error: 'updates array is required' }, 400);
  }
  await ticketsService.reorderTickets(body.updates);
  return c.json({ success: true });
});

export default app;
```

**File:** `apps/server/src/index.ts` (update)
- Add: `import ticketsRoutes from './routes/tickets';`
- Add: `app.route('/api/tickets', ticketsRoutes);`

**Acceptance Criteria:**
- [ ] GET /api/tickets returns all tickets
- [ ] GET /api/tickets?projectId=xxx filters by project
- [ ] POST /api/tickets creates ticket in backlog status
- [ ] PATCH /api/tickets/:id updates ticket fields
- [ ] DELETE /api/tickets/:id removes ticket
- [ ] PATCH /api/tickets/:id/status updates status and position
- [ ] POST /api/tickets/reorder updates multiple tickets atomically
- [ ] Deleting project cascades to delete its tickets

### 5. Frontend Shell and Routing

Set up the React application shell with routing, layout, and API client.

**File:** `apps/web/src/main.tsx`

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import App from './App';
import './index.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60, // 1 minute
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>
);
```

**File:** `apps/web/src/App.tsx`

```typescript
import { Routes, Route } from 'react-router-dom';
import Layout from './components/Layout';
import DashboardPage from './pages/DashboardPage';
import ProjectsPage from './pages/ProjectsPage';

export default function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<DashboardPage />} />
        <Route path="projects" element={<ProjectsPage />} />
      </Route>
    </Routes>
  );
}
```

**File:** `apps/web/src/components/Layout.tsx`

- Sidebar with navigation links:
  - Dashboard (icon: grid/kanban)
  - Projects (icon: folder)
- Main content area with `<Outlet />`
- App title "RALPH Blaster" in sidebar header
- Dark background (#0f0f0f or similar dark theme)
- Sidebar width: 240px
- Responsive: collapse sidebar on mobile

**File:** `apps/web/src/lib/api.ts`

```typescript
const API_BASE = '/api';

async function request<T>(path: string, options?: RequestInit): Promise<T> {
  const response = await fetch(`${API_BASE}${path}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    ...options,
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    throw new Error(error.error || `HTTP ${response.status}`);
  }

  return response.json();
}

export const api = {
  get: <T>(path: string) => request<T>(path),
  post: <T>(path: string, data: unknown) => request<T>(path, { method: 'POST', body: JSON.stringify(data) }),
  patch: <T>(path: string, data: unknown) => request<T>(path, { method: 'PATCH', body: JSON.stringify(data) }),
  delete: <T>(path: string) => request<T>(path, { method: 'DELETE' }),
};
```

**File:** `apps/web/src/index.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
}

body {
  @apply bg-neutral-950 text-neutral-100;
}
```

**File:** `apps/web/src/pages/DashboardPage.tsx`
- Placeholder: "Dashboard - Kanban board coming soon"

**File:** `apps/web/src/pages/ProjectsPage.tsx`
- Placeholder: "Projects page coming soon"

**Acceptance Criteria:**
- [ ] App renders without errors
- [ ] Navigation between / and /projects works
- [ ] Layout has sidebar with navigation links
- [ ] Dark theme applied
- [ ] API client can make requests (test with /health endpoint)
- [ ] TanStack Query provider configured

### 6. Projects Management UI

Build the projects list and create/edit modal.

**File:** `apps/web/src/hooks/useProjects.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '../lib/api';
import type { Project, CreateProjectInput, UpdateProjectInput } from '@vibehq/shared';

export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: () => api.get<Project[]>('/projects'),
  });
}

export function useProject(id: string) {
  return useQuery({
    queryKey: ['projects', id],
    queryFn: () => api.get<Project>(`/projects/${id}`),
    enabled: !!id,
  });
}

export function useCreateProject() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateProjectInput) => api.post<Project>('/projects', data),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['projects'] }),
  });
}

export function useUpdateProject() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateProjectInput }) =>
      api.patch<Project>(`/projects/${id}`, data),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['projects'] }),
  });
}

export function useDeleteProject() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.delete(`/projects/${id}`),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['projects'] }),
  });
}
```

**File:** `apps/web/src/pages/ProjectsPage.tsx`

- Header: "Projects" title + "New Project" button
- Grid of project cards (2-3 columns)
- Each card shows:
  - Project name (large)
  - Path (truncated, smaller text)
  - Edit button (pencil icon)
  - Delete button (trash icon, with confirmation)
- Loading state: skeleton cards
- Empty state: "No projects yet. Create your first project."
- Click "New Project" or "Edit" opens ProjectModal

**File:** `apps/web/src/components/ProjectModal.tsx`

```typescript
interface ProjectModalProps {
  project?: Project; // undefined = create mode, defined = edit mode
  isOpen: boolean;
  onClose: () => void;
}
```

- Modal overlay with centered card
- Title: "New Project" or "Edit Project"
- Form fields:
  - Name: text input, required
  - Path: text input, required, placeholder "/path/to/your/project"
- Buttons: Cancel, Save
- On save: call create or update mutation, close on success
- Validation: show error if fields empty
- Loading state on save button

**File:** `apps/web/src/components/ConfirmDialog.tsx`

- Reusable confirmation dialog
- Props: title, message, confirmLabel, onConfirm, onCancel, isOpen
- Destructive styling for delete confirmations

**Acceptance Criteria:**
- [ ] Projects page lists all projects
- [ ] Can create new project via modal
- [ ] Can edit existing project via modal
- [ ] Can delete project with confirmation
- [ ] Loading states while fetching/mutating
- [ ] Empty state when no projects
- [ ] Form validation prevents empty submissions

### 7. Kanban Board Layout

Build the kanban board structure with columns for each status.

**File:** `apps/web/src/hooks/useTickets.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '../lib/api';
import type { Ticket, CreateTicketInput, UpdateTicketInput, TicketStatus } from '@vibehq/shared';

export function useTickets(projectId?: string) {
  return useQuery({
    queryKey: ['tickets', { projectId }],
    queryFn: () => api.get<Ticket[]>(projectId ? `/tickets?projectId=${projectId}` : '/tickets'),
  });
}

export function useTicket(id: string) {
  return useQuery({
    queryKey: ['tickets', id],
    queryFn: () => api.get<Ticket>(`/tickets/${id}`),
    enabled: !!id,
  });
}

export function useCreateTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateTicketInput) => api.post<Ticket>('/tickets', data),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['tickets'] }),
  });
}

export function useUpdateTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateTicketInput }) =>
      api.patch<Ticket>(`/tickets/${id}`, data),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['tickets'] }),
  });
}

export function useDeleteTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.delete(`/tickets/${id}`),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['tickets'] }),
  });
}
```

**File:** `apps/web/src/pages/DashboardPage.tsx`

- Header section:
  - Title: "Dashboard"
  - Project filter dropdown (select from all projects, or "All Projects")
  - "New Ticket" button
- KanbanBoard component below header
- State for selected project filter
- State for selected ticket (for detail panel, next item)

**File:** `apps/web/src/components/KanbanBoard.tsx`

```typescript
interface KanbanBoardProps {
  tickets: Ticket[];
  onTicketClick: (ticket: Ticket) => void;
}
```

- Horizontal container with 6 columns
- Overflow-x-auto for horizontal scroll on small screens
- Map over TICKET_STATUSES to render KanbanColumn for each
- Filter tickets by status for each column
- Sort tickets by position within each column

**File:** `apps/web/src/components/KanbanColumn.tsx`

```typescript
interface KanbanColumnProps {
  status: TicketStatus;
  tickets: Ticket[];
  onTicketClick: (ticket: Ticket) => void;
}
```

- Column header with:
  - Status name (formatted: "backlog" → "Backlog", "in_progress" → "In Progress")
  - Ticket count badge
- Column styling:
  - Fixed width: 280px
  - Background: slightly lighter than page bg
  - Rounded corners
  - Min-height to fill available space
- Scrollable ticket list inside column
- Render TicketCard for each ticket
- Empty state: subtle text "No tickets"

**File:** `apps/web/src/components/TicketCard.tsx`

```typescript
interface TicketCardProps {
  ticket: Ticket;
  onClick: () => void;
}
```

- Card styling:
  - Background: card color (slightly lighter)
  - Rounded, padding, shadow
  - Hover effect (slight lift/glow)
  - Cursor pointer
- Content:
  - Title (bold, truncate if long with ellipsis)
  - Project badge (small, colored chip)
  - Image indicator icon if ticket has attachments (optional for now)
  - Status-specific accent color on left border

**Status colors (for borders/accents):**
- backlog: gray
- up_next: blue
- in_review: yellow
- in_progress: purple
- in_testing: orange
- completed: green

**Acceptance Criteria:**
- [ ] Kanban board renders with 6 columns
- [ ] Tickets appear in correct columns based on status
- [ ] Project filter dropdown works
- [ ] Clicking ticket card triggers onTicketClick
- [ ] Columns are horizontally scrollable
- [ ] Status names formatted properly
- [ ] Empty columns show "No tickets"

### 8. Drag and Drop Implementation

Add drag-and-drop functionality to the kanban board using @dnd-kit.

**File:** `apps/web/src/hooks/useTickets.ts` (update)

Add these mutations:

```typescript
export function useUpdateTicketStatus() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, status, position }: { id: string; status: TicketStatus; position: number }) =>
      api.patch<Ticket>(`/tickets/${id}/status`, { status, position }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['tickets'] }),
  });
}

export function useReorderTickets() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (updates: Array<{ id: string; status: TicketStatus; position: number }>) =>
      api.post('/tickets/reorder', { updates }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['tickets'] }),
  });
}
```

**File:** `apps/web/src/components/KanbanBoard.tsx` (update)

```typescript
import {
  DndContext,
  DragOverlay,
  closestCorners,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragEndEvent,
  DragOverEvent,
} from '@dnd-kit/core';
import { sortableKeyboardCoordinates } from '@dnd-kit/sortable';
```

- Wrap board in DndContext
- Configure sensors: PointerSensor, KeyboardSensor
- Track activeId state (currently dragging ticket)
- Handle onDragStart: set activeId
- Handle onDragOver: preview ticket in target column
- Handle onDragEnd: finalize move
- DragOverlay to show card being dragged

**Drag end logic:**
1. Get source ticket and destination info
2. If dropped in same column at same position → no-op
3. If dropped in different column → call updateTicketStatus with new status and position at end
4. If dropped in same column different position → call reorderTickets to update positions

**File:** `apps/web/src/components/KanbanColumn.tsx` (update)

```typescript
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
```

- Make column droppable using useDroppable with id = status
- Wrap ticket list in SortableContext
- Visual feedback when dragging over (highlight border)

**File:** `apps/web/src/components/SortableTicketCard.tsx` (new)

```typescript
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface SortableTicketCardProps {
  ticket: Ticket;
  onClick: () => void;
}
```

- Wrap TicketCard with useSortable
- Apply transform and transition styles from useSortable
- Add drag handle (optional) or make entire card draggable
- Visual feedback while dragging (opacity, shadow)

**File:** `apps/web/src/components/TicketCard.tsx` (update)

- Accept optional `isDragging` prop for styling
- When isDragging: add shadow, slight scale, reduced opacity in original position

**Optimistic updates:**
- When dragging ends, immediately update local state
- If mutation fails, rollback and show error toast

**Acceptance Criteria:**
- [ ] Can drag ticket from one column to another
- [ ] Ticket status updates in database on drop
- [ ] Can reorder tickets within same column
- [ ] Smooth drag animation with DragOverlay
- [ ] Visual feedback on drag over column
- [ ] Keyboard accessibility (tab, space, arrows)
- [ ] Error handling with rollback on failure

### 9. Ticket Detail Panel

Create a slide-out panel for viewing and editing ticket details.

**File:** `apps/web/src/components/TicketDetailPanel.tsx`

```typescript
interface TicketDetailPanelProps {
  ticket: Ticket | null;
  isOpen: boolean;
  onClose: () => void;
}
```

- Slide-in panel from right side of screen
- Width: 480px (or 40% on large screens)
- Dark overlay behind panel (click to close)
- Escape key closes panel
- Smooth slide animation

**Panel content:**

Header section:
- Close button (X icon) top right
- Delete button (trash icon) with confirmation

Ticket info section:
- Title: large text, click to edit inline (or edit icon to open edit mode)
- Project: read-only badge showing project name
- Status: dropdown to change status
- Created/Updated: timestamps in relative format ("2 hours ago")

Description section:
- Label "Description"
- Markdown content display (or plain text for now)
- Edit button to switch to textarea edit mode
- Save/Cancel buttons when editing

Images section (placeholder for now):
- Label "Attachments"
- Will be implemented in Item 10

PRD section (placeholder for now):
- Label "PRD"
- Will be implemented in Item 12

**File:** `apps/web/src/components/TicketForm.tsx`

```typescript
interface TicketFormProps {
  ticket?: Ticket; // undefined = create, defined = edit
  projectId?: string; // pre-selected project for create
  onSubmit: (data: CreateTicketInput | UpdateTicketInput) => void;
  onCancel: () => void;
  isLoading?: boolean;
}
```

- Form fields:
  - Title: text input, required
  - Project: dropdown (only for create, disabled for edit)
  - Description: textarea, required
- Validation before submit
- Loading state on submit button

**File:** `apps/web/src/pages/DashboardPage.tsx` (update)

- State: `selectedTicketId: string | null`
- On ticket card click: set selectedTicketId
- Pass to TicketDetailPanel
- URL sync: update URL with `?ticket=xxx` query param
- On page load: check URL for ticket param, open panel if present

**File:** `apps/web/src/components/NewTicketModal.tsx`

- Modal for creating new tickets
- Uses TicketForm component
- Called from "New Ticket" button on dashboard

**Acceptance Criteria:**
- [ ] Clicking ticket opens detail panel
- [ ] Panel slides in from right with animation
- [ ] Can view all ticket details
- [ ] Can edit title and description
- [ ] Can change status from dropdown
- [ ] Can delete ticket with confirmation
- [ ] Panel closes on X, overlay click, or Escape
- [ ] URL updates with ticket ID for deep linking
- [ ] Can create new ticket from dashboard

### 10. Image Upload and Attachments

Implement image upload for tickets.

**File:** `apps/server/src/services/images.ts`

```typescript
import { db, ticketImages } from '../db';
import { eq } from 'drizzle-orm';
import { nanoid } from 'nanoid';
import { mkdir, unlink } from 'fs/promises';
import type { TicketImage } from '@vibehq/shared';

const UPLOADS_DIR = './data/uploads';

export async function ensureUploadsDir(): Promise<void> {
  await mkdir(UPLOADS_DIR, { recursive: true });
}

export async function uploadImage(ticketId: string, file: File): Promise<TicketImage> {
  const id = nanoid();
  const ext = file.name.split('.').pop() || 'bin';
  const storagePath = `${ticketId}-${id}.${ext}`;
  const fullPath = `${UPLOADS_DIR}/${storagePath}`;

  await Bun.write(fullPath, file);

  const [image] = await db.insert(ticketImages).values({
    id,
    ticketId,
    filename: file.name,
    storagePath,
    mimeType: file.type,
    size: file.size,
  }).returning();

  return image;
}

export async function deleteImage(id: string): Promise<void> {
  const [image] = await db.select().from(ticketImages).where(eq(ticketImages.id, id));
  if (image) {
    await unlink(`${UPLOADS_DIR}/${image.storagePath}`).catch(() => {});
    await db.delete(ticketImages).where(eq(ticketImages.id, id));
  }
}

export async function getImagesForTicket(ticketId: string): Promise<TicketImage[]> {
  return db.select().from(ticketImages).where(eq(ticketImages.ticketId, ticketId));
}
```

**File:** `apps/server/src/routes/images.ts`

```typescript
import { Hono } from 'hono';
import * as imagesService from '../services/images';

const app = new Hono();

// POST /api/tickets/:ticketId/images - Upload image
app.post('/tickets/:ticketId/images', async (c) => {
  const ticketId = c.req.param('ticketId');
  const formData = await c.req.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return c.json({ error: 'No file provided' }, 400);
  }

  // Validate file type
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedTypes.includes(file.type)) {
    return c.json({ error: 'Invalid file type. Allowed: jpg, png, gif, webp' }, 400);
  }

  // Validate file size (max 10MB)
  if (file.size > 10 * 1024 * 1024) {
    return c.json({ error: 'File too large. Max 10MB' }, 400);
  }

  const image = await imagesService.uploadImage(ticketId, file);
  return c.json(image, 201);
});

// GET /api/tickets/:ticketId/images - List images for ticket
app.get('/tickets/:ticketId/images', async (c) => {
  const images = await imagesService.getImagesForTicket(c.req.param('ticketId'));
  return c.json(images);
});

// DELETE /api/images/:id - Delete image
app.delete('/images/:id', async (c) => {
  await imagesService.deleteImage(c.req.param('id'));
  return c.json({ success: true });
});

export default app;
```

**File:** `apps/server/src/routes/static.ts`

```typescript
import { Hono } from 'hono';
import { serveStatic } from 'hono/bun';

const app = new Hono();

// Serve uploaded files
app.use('/uploads/*', serveStatic({ root: './data' }));

export default app;
```

**File:** `apps/server/src/index.ts` (update)
- Add: `import imagesRoutes from './routes/images';`
- Add: `import staticRoutes from './routes/static';`
- Add: `app.route('/api', imagesRoutes);`
- Add: `app.route('/', staticRoutes);`
- Call `ensureUploadsDir()` on startup

**File:** `apps/web/src/hooks/useImages.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type { TicketImage } from '@vibehq/shared';

export function useImages(ticketId: string) {
  return useQuery({
    queryKey: ['images', ticketId],
    queryFn: async () => {
      const res = await fetch(`/api/tickets/${ticketId}/images`);
      return res.json() as Promise<TicketImage[]>;
    },
    enabled: !!ticketId,
  });
}

export function useUploadImage() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ ticketId, file }: { ticketId: string; file: File }) => {
      const formData = new FormData();
      formData.append('file', file);
      const res = await fetch(`/api/tickets/${ticketId}/images`, {
        method: 'POST',
        body: formData,
      });
      if (!res.ok) throw new Error('Upload failed');
      return res.json();
    },
    onSuccess: (_, { ticketId }) => {
      queryClient.invalidateQueries({ queryKey: ['images', ticketId] });
    },
  });
}

export function useDeleteImage() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (id: string) => {
      await fetch(`/api/images/${id}`, { method: 'DELETE' });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['images'] });
    },
  });
}
```

**File:** `apps/web/src/components/ImageUpload.tsx`

```typescript
interface ImageUploadProps {
  ticketId: string;
  images: TicketImage[];
  onUpload: (file: File) => void;
  onDelete: (id: string) => void;
  isUploading?: boolean;
}
```

- Drag-and-drop zone with dashed border
- "Drop images here or click to upload" text
- Hidden file input triggered on click
- Accept only image types
- Show upload progress/spinner when uploading
- Grid of uploaded images below:
  - Thumbnail preview
  - Filename
  - Delete button (X) with confirmation
- Click thumbnail to open in new tab (full size)

**File:** `apps/web/src/components/TicketDetailPanel.tsx` (update)

- Import and use ImageUpload component
- Fetch images using useImages hook
- Pass upload/delete handlers

**Acceptance Criteria:**
- [ ] Can upload images via drag-drop or file picker
- [ ] Images stored in `apps/server/data/uploads/`
- [ ] Image metadata saved to database
- [ ] Images display as thumbnails in ticket panel
- [ ] Can delete uploaded images
- [ ] File type validation (only images)
- [ ] File size validation (max 10MB)
- [ ] Images served via /uploads/:filename

### 11. PRD Generation with Claude Code

Implement PRD generation by calling Claude Code CLI.

**File:** `apps/server/src/services/prd-generator.ts`

```typescript
import type { Ticket, Project, TicketImage } from '@vibehq/shared';
import { exec } from '../utils/shell';

const PRD_PROMPT_TEMPLATE = `You are generating a PRD (Product Requirements Document) for the RALPH autonomous coding system.

Project: {{projectName}}
Codebase: {{projectPath}}

Feature Request:
Title: {{ticketTitle}}
Description:
{{ticketDescription}}

{{#if images}}
Reference images are attached at these paths (you can view them):
{{#each images}}
- {{this}}
{{/each}}
{{/if}}

Generate a detailed PRD in markdown format following this structure:

# PRD: {{ticketTitle}}

## Overview
Brief description of what needs to be implemented.

## Items
Break down into specific, actionable tasks. Each task should be completable in one RALPH iteration.

### 1. [Task Name]
- [ ] Detailed description
- Files to create/modify
- Acceptance criteria

### 2. [Task Name]
...

## Quality Requirements
- List specific quality checks (typecheck, lint, tests)
- Reference existing patterns in the codebase

## Priority Order
List tasks in recommended implementation order with brief reasoning.

## Notes
Any additional context RALPH needs.

Keep the PRD concise but specific enough for autonomous implementation. Focus on WHAT needs to be done, not HOW.`;

export async function generatePRD(
  ticket: Ticket,
  project: Project,
  images: TicketImage[]
): Promise<string> {
  // Build prompt from template
  let prompt = PRD_PROMPT_TEMPLATE
    .replace('{{projectName}}', project.name)
    .replace('{{projectPath}}', project.path)
    .replace(/\{\{ticketTitle\}\}/g, ticket.title)
    .replace('{{ticketDescription}}', ticket.description);

  // Handle images section
  if (images.length > 0) {
    const imagePaths = images.map(img => `./data/uploads/${img.storagePath}`).join('\n- ');
    prompt = prompt
      .replace('{{#if images}}', '')
      .replace('{{/if}}', '')
      .replace('{{#each images}}\n- {{this}}\n{{/each}}', imagePaths);
  } else {
    // Remove images section entirely
    prompt = prompt.replace(/\{\{#if images\}\}[\s\S]*?\{\{\/if\}\}/g, '');
  }

  // Call Claude Code CLI
  const { stdout, stderr, exitCode } = await exec(
    `claude --print "${prompt.replace(/"/g, '\\"')}"`,
    { cwd: project.path, timeout: 120000 } // 2 minute timeout
  );

  if (exitCode !== 0) {
    throw new Error(`Claude Code failed: ${stderr}`);
  }

  return stdout.trim();
}
```

**File:** `apps/server/src/utils/shell.ts`

```typescript
export interface ExecResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

export async function exec(
  command: string,
  options?: { cwd?: string; timeout?: number }
): Promise<ExecResult> {
  const proc = Bun.spawn(['bash', '-c', command], {
    cwd: options?.cwd,
    stdout: 'pipe',
    stderr: 'pipe',
  });

  // Handle timeout
  const timeoutMs = options?.timeout || 60000;
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => {
      proc.kill();
      reject(new Error(`Command timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });

  try {
    const [stdout, stderr] = await Promise.race([
      Promise.all([
        new Response(proc.stdout).text(),
        new Response(proc.stderr).text(),
      ]),
      timeoutPromise,
    ]);

    const exitCode = await proc.exited;

    return { stdout, stderr, exitCode };
  } catch (error) {
    throw error;
  }
}
```

**File:** `apps/server/src/routes/tickets.ts` (update)

Add new endpoint:

```typescript
import * as prdGenerator from '../services/prd-generator';
import * as imagesService from '../services/images';
import * as projectsService from '../services/projects';

// POST /api/tickets/:id/generate-prd - Generate PRD for ticket
app.post('/:id/generate-prd', async (c) => {
  const ticketId = c.req.param('id');

  // Get ticket
  const ticket = await ticketsService.getTicket(ticketId);
  if (!ticket) return c.json({ error: 'Ticket not found' }, 404);

  // Get project
  const project = await projectsService.getProject(ticket.projectId);
  if (!project) return c.json({ error: 'Project not found' }, 404);

  // Get images
  const images = await imagesService.getImagesForTicket(ticketId);

  try {
    // Generate PRD
    const prdContent = await prdGenerator.generatePRD(ticket, project, images);

    // Update ticket with PRD and move to in_review
    const updatedTicket = await ticketsService.updateTicket(ticketId, {
      prdContent,
      status: 'in_review',
    });

    return c.json(updatedTicket);
  } catch (error) {
    console.error('PRD generation failed:', error);
    return c.json({ error: 'PRD generation failed. Is Claude Code installed?' }, 500);
  }
});
```

**File:** `apps/web/src/hooks/useTickets.ts` (update)

Add mutation:

```typescript
export function useGeneratePRD() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (ticketId: string) => {
      const res = await fetch(`/api/tickets/${ticketId}/generate-prd`, { method: 'POST' });
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.error || 'Failed to generate PRD');
      }
      return res.json() as Promise<Ticket>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}
```

**Acceptance Criteria:**
- [ ] POST /api/tickets/:id/generate-prd calls Claude Code
- [ ] PRD content saved to ticket.prdContent
- [ ] Ticket status changes to 'in_review' after generation
- [ ] Images passed to Claude Code prompt if present
- [ ] Timeout handling (2 minutes max)
- [ ] Error handling if Claude Code not installed
- [ ] Error handling if Claude Code returns error

### 12. PRD Review and Approval UI

Build the UI for reviewing, editing, and approving generated PRDs.

**File:** `apps/web/src/components/PRDViewer.tsx`

```typescript
interface PRDViewerProps {
  content: string;
  onEdit: () => void;
}
```

- Display PRD markdown with proper formatting
- Use a simple markdown renderer (can use regex-based for now, or add react-markdown later)
- Format:
  - Headers (h1, h2, h3) with proper sizing
  - Code blocks with monospace font and background
  - Bullet lists
  - Checkboxes (render as visual checkboxes)
- "Edit" button in top right corner
- Scrollable container if content is long

**File:** `apps/web/src/components/PRDEditor.tsx`

```typescript
interface PRDEditorProps {
  content: string;
  onSave: (content: string) => void;
  onCancel: () => void;
  isSaving?: boolean;
}
```

- Full-height textarea for editing markdown
- Monospace font
- Save and Cancel buttons
- Character count (optional)
- Warn if content is empty on save

**File:** `apps/web/src/components/TicketDetailPanel.tsx` (update)

Add PRD section with conditional rendering based on ticket status:

```typescript
// When status is 'up_next'
{ticket.status === 'up_next' && (
  <div>
    <Button onClick={handleGeneratePRD} disabled={isGenerating}>
      {isGenerating ? 'Generating PRD...' : 'Generate PRD'}
    </Button>
  </div>
)}

// When status is 'in_review' (PRD exists)
{ticket.status === 'in_review' && ticket.prdContent && (
  <div>
    {isEditingPRD ? (
      <PRDEditor
        content={prdContent}
        onSave={handleSavePRD}
        onCancel={() => setIsEditingPRD(false)}
        isSaving={isSavingPRD}
      />
    ) : (
      <PRDViewer
        content={ticket.prdContent}
        onEdit={() => setIsEditingPRD(true)}
      />
    )}
    <Button onClick={handleApproveAndLaunch} variant="primary">
      Approve and Launch RALPH
    </Button>
  </div>
)}

// When status is 'in_progress', 'in_testing', or 'completed'
{['in_progress', 'in_testing', 'completed'].includes(ticket.status) && ticket.prdContent && (
  <PRDViewer content={ticket.prdContent} onEdit={() => {}} />
  // Edit disabled for these statuses
)}
```

**File:** `apps/web/src/hooks/useTickets.ts` (update)

Add mutation for approval:

```typescript
export function useApprovePRD() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (ticketId: string) => {
      // This will be connected to RALPH launch in next items
      // For now, just move to in_progress
      const res = await fetch(`/api/tickets/${ticketId}/approve`, { method: 'POST' });
      if (!res.ok) throw new Error('Failed to approve');
      return res.json() as Promise<Ticket>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}
```

**File:** `apps/server/src/routes/tickets.ts` (update)

Add approval endpoint (placeholder for now):

```typescript
// POST /api/tickets/:id/approve - Approve PRD and launch RALPH
app.post('/:id/approve', async (c) => {
  const ticketId = c.req.param('id');
  const ticket = await ticketsService.getTicket(ticketId);

  if (!ticket) return c.json({ error: 'Ticket not found' }, 404);
  if (ticket.status !== 'in_review') {
    return c.json({ error: 'Ticket must be in review status' }, 400);
  }
  if (!ticket.prdContent) {
    return c.json({ error: 'Ticket has no PRD content' }, 400);
  }

  // For now, just move to in_progress
  // RALPH launch will be added in Item 14
  const updatedTicket = await ticketsService.updateTicket(ticketId, {
    status: 'in_progress',
  });

  return c.json(updatedTicket);
});
```

**UI Flow:**

1. Ticket in "Up Next" column
   - User clicks ticket → panel opens
   - "Generate PRD" button visible
   - Click → loading spinner → PRD generated → ticket moves to "In Review"

2. Ticket in "In Review" column
   - PRD content displayed
   - "Edit" button to modify PRD
   - "Approve and Launch RALPH" button
   - Click approve → ticket moves to "In Progress"

**Acceptance Criteria:**
- [ ] PRD displays with proper markdown formatting
- [ ] Can edit PRD content and save changes
- [ ] "Generate PRD" button visible for 'up_next' tickets
- [ ] "Approve and Launch RALPH" button visible for 'in_review' tickets
- [ ] Loading state during PRD generation
- [ ] Ticket status updates after approval
- [ ] Error handling for generation failures

### 13. Git Worktree Management

Implement git worktree creation and cleanup for parallel RALPH execution.

**File:** `apps/server/src/services/worktree.ts`

```typescript
import { exec } from '../utils/shell';
import { mkdir, rm } from 'fs/promises';

export interface WorktreeInfo {
  path: string;
  branch: string;
  head: string;
}

/**
 * Create a git worktree with a new branch for a ticket
 */
export async function createWorktree(
  projectPath: string,
  ticketId: string,
  ticketTitle: string
): Promise<{ worktreePath: string; branchName: string }> {
  // Generate branch name: ralph/{ticketId}-{slugified-title}
  const slug = ticketTitle
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 30);
  const branchName = `ralph/${ticketId}-${slug}`;

  // Worktree directory inside project
  const worktreesDir = `${projectPath}/.ralph-worktrees`;
  const worktreePath = `${worktreesDir}/${ticketId}`;

  // Ensure worktrees directory exists
  await mkdir(worktreesDir, { recursive: true });

  // Create worktree with new branch
  // First, get the current branch name to base off of
  const { stdout: currentBranch } = await exec(
    'git rev-parse --abbrev-ref HEAD',
    { cwd: projectPath }
  );

  const { exitCode, stderr } = await exec(
    `git worktree add -b "${branchName}" "${worktreePath}" ${currentBranch.trim()}`,
    { cwd: projectPath }
  );

  if (exitCode !== 0) {
    throw new Error(`Failed to create worktree: ${stderr}`);
  }

  return { worktreePath, branchName };
}

/**
 * Delete a git worktree and optionally its branch
 */
export async function deleteWorktree(
  projectPath: string,
  worktreePath: string,
  branchName?: string,
  deleteBranch: boolean = false
): Promise<void> {
  // Remove the worktree
  const { exitCode: removeExitCode, stderr: removeStderr } = await exec(
    `git worktree remove "${worktreePath}" --force`,
    { cwd: projectPath }
  );

  // If worktree remove fails, try to force remove the directory
  if (removeExitCode !== 0) {
    console.warn(`Worktree remove failed: ${removeStderr}, trying manual cleanup`);
    await rm(worktreePath, { recursive: true, force: true });

    // Prune worktrees
    await exec('git worktree prune', { cwd: projectPath });
  }

  // Optionally delete the branch
  if (deleteBranch && branchName) {
    await exec(`git branch -D "${branchName}"`, { cwd: projectPath });
  }
}

/**
 * List all worktrees for a project
 */
export async function listWorktrees(projectPath: string): Promise<WorktreeInfo[]> {
  const { stdout, exitCode } = await exec(
    'git worktree list --porcelain',
    { cwd: projectPath }
  );

  if (exitCode !== 0) return [];

  const worktrees: WorktreeInfo[] = [];
  let current: Partial<WorktreeInfo> = {};

  for (const line of stdout.split('\n')) {
    if (line.startsWith('worktree ')) {
      if (current.path) worktrees.push(current as WorktreeInfo);
      current = { path: line.slice(9) };
    } else if (line.startsWith('HEAD ')) {
      current.head = line.slice(5);
    } else if (line.startsWith('branch ')) {
      current.branch = line.slice(7);
    }
  }

  if (current.path) worktrees.push(current as WorktreeInfo);

  // Filter to only ralph worktrees
  return worktrees.filter(w => w.path.includes('.ralph-worktrees'));
}

/**
 * Check if a path is a valid git repository
 */
export async function isGitRepo(path: string): Promise<boolean> {
  const { exitCode } = await exec('git rev-parse --git-dir', { cwd: path });
  return exitCode === 0;
}

/**
 * Get the main/master branch name
 */
export async function getMainBranch(projectPath: string): Promise<string> {
  // Check for main first, then master
  const { exitCode: mainExitCode } = await exec(
    'git rev-parse --verify main',
    { cwd: projectPath }
  );
  if (mainExitCode === 0) return 'main';

  const { exitCode: masterExitCode } = await exec(
    'git rev-parse --verify master',
    { cwd: projectPath }
  );
  if (masterExitCode === 0) return 'master';

  // Fall back to current branch
  const { stdout } = await exec(
    'git rev-parse --abbrev-ref HEAD',
    { cwd: projectPath }
  );
  return stdout.trim();
}
```

**File:** `packages/shared/src/types.ts` (update)

Add WorktreeInfo type:

```typescript
export interface WorktreeInfo {
  path: string;
  branch: string;
  head: string;
}
```

**Acceptance Criteria:**
- [ ] Can create worktree with new branch for a ticket
- [ ] Branch names follow pattern `ralph/{ticketId}-{slug}`
- [ ] Worktrees created in `{projectPath}/.ralph-worktrees/`
- [ ] Can delete worktree and optionally its branch
- [ ] Can list all RALPH worktrees for a project
- [ ] Error handling for git failures
- [ ] Works with any git repository
- [ ] Validates project path is a git repo

### 14. RALPH Instance Management

Implement RALPH instance creation, process spawning, and tracking.

**File:** `apps/server/src/services/ralph.ts`

```typescript
import { db, ralphInstances, tickets } from '../db';
import { eq } from 'drizzle-orm';
import { nanoid } from 'nanoid';
import { mkdir, writeFile } from 'fs/promises';
import { exec } from '../utils/shell';
import * as worktreeService from './worktree';
import * as ticketsService from './tickets';
import * as projectsService from './projects';
import type { RalphInstance, Ticket, Project } from '@vibehq/shared';

// Store running processes (in memory)
const runningProcesses = new Map<string, { proc: Subprocess; logStream: WritableStream }>();

/**
 * Create a RALPH instance for a ticket
 */
export async function createRalphInstance(
  ticket: Ticket,
  project: Project
): Promise<RalphInstance> {
  const id = nanoid();

  // Create worktree
  const { worktreePath, branchName } = await worktreeService.createWorktree(
    project.path,
    ticket.id,
    ticket.title
  );

  // Create instance directory inside worktree
  const instanceDir = `${worktreePath}/.ralph-instance`;
  await mkdir(instanceDir, { recursive: true });

  // Write PRD file
  const prdFilePath = `${instanceDir}/prd.md`;
  await writeFile(prdFilePath, ticket.prdContent || '');

  // Write empty progress file
  const progressPath = `${instanceDir}/progress.txt`;
  await writeFile(progressPath, '');

  // Generate RALPH script
  const scriptPath = `${instanceDir}/run-ralph.sh`;
  const logPath = `${instanceDir}/ralph.log`;

  const scriptContent = `#!/bin/bash
set -e
cd "${worktreePath}"

# Run RALPH using Claude Code
claude --dangerously-skip-permissions --print "You are RALPH, an autonomous coding agent.

Read the PRD at ${prdFilePath} to understand what needs to be built.
Read the progress file at ${progressPath} to see what has already been done.

Your task:
1. Identify the next incomplete item from the PRD
2. Implement it fully
3. Run any type checking or linting commands specified in the PRD
4. Commit your changes with a descriptive message
5. Update ${progressPath} with what you completed

If all items in the PRD are complete, output: RALPH_COMPLETE

Work autonomously. Make decisions. Ship code." 2>&1 | tee -a "${logPath}"
`;

  await writeFile(scriptPath, scriptContent);
  await exec(`chmod +x "${scriptPath}"`);

  // Update ticket with branch name
  await ticketsService.updateTicket(ticket.id, { branchName });

  // Create database record
  const [instance] = await db.insert(ralphInstances).values({
    id,
    ticketId: ticket.id,
    status: 'pending',
    worktreePath,
    logPath,
    prdFilePath,
    scriptPath,
  }).returning();

  return instance as RalphInstance;
}

/**
 * Start a RALPH instance
 */
export async function startRalphInstance(instanceId: string): Promise<void> {
  const [instance] = await db.select()
    .from(ralphInstances)
    .where(eq(ralphInstances.id, instanceId));

  if (!instance) throw new Error('Instance not found');
  if (instance.status === 'running') throw new Error('Instance already running');

  // Spawn the RALPH process
  const proc = Bun.spawn(['bash', instance.scriptPath!], {
    cwd: instance.worktreePath!,
    stdout: 'pipe',
    stderr: 'pipe',
  });

  // Store process reference
  runningProcesses.set(instanceId, { proc, logStream: null as any });

  // Update database with PID and status
  await db.update(ralphInstances)
    .set({
      status: 'running',
      pid: proc.pid,
      startedAt: new Date(),
    })
    .where(eq(ralphInstances.id, instanceId));
}

/**
 * Stop a running RALPH instance
 */
export async function stopRalphInstance(instanceId: string): Promise<void> {
  const processInfo = runningProcesses.get(instanceId);
  if (processInfo) {
    processInfo.proc.kill();
    runningProcesses.delete(instanceId);
  }

  await db.update(ralphInstances)
    .set({
      status: 'failed',
      completedAt: new Date(),
    })
    .where(eq(ralphInstances.id, instanceId));
}

/**
 * Get RALPH instance by ID
 */
export async function getRalphInstance(id: string): Promise<RalphInstance | null> {
  const [instance] = await db.select()
    .from(ralphInstances)
    .where(eq(ralphInstances.id, id));
  return instance as RalphInstance || null;
}

/**
 * Get RALPH instance for a ticket
 */
export async function getRalphInstanceForTicket(ticketId: string): Promise<RalphInstance | null> {
  const [instance] = await db.select()
    .from(ralphInstances)
    .where(eq(ralphInstances.ticketId, ticketId))
    .orderBy(ralphInstances.createdAt);
  return instance as RalphInstance || null;
}

/**
 * Get all running instances
 */
export async function getRunningInstances(): Promise<RalphInstance[]> {
  return db.select()
    .from(ralphInstances)
    .where(eq(ralphInstances.status, 'running')) as Promise<RalphInstance[]>;
}

/**
 * Check if a process is still running
 */
export function isProcessRunning(pid: number): boolean {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}
```

**File:** `apps/server/src/routes/ralph.ts`

```typescript
import { Hono } from 'hono';
import * as ralphService from '../services/ralph';
import * as ticketsService from '../services/tickets';
import * as projectsService from '../services/projects';
import { readFile } from 'fs/promises';

const app = new Hono();

// POST /api/tickets/:id/launch-ralph - Create and start RALPH instance
app.post('/tickets/:id/launch-ralph', async (c) => {
  const ticketId = c.req.param('id');

  const ticket = await ticketsService.getTicket(ticketId);
  if (!ticket) return c.json({ error: 'Ticket not found' }, 404);
  if (!ticket.prdContent) return c.json({ error: 'Ticket has no PRD' }, 400);

  const project = await projectsService.getProject(ticket.projectId);
  if (!project) return c.json({ error: 'Project not found' }, 404);

  try {
    // Create instance
    const instance = await ralphService.createRalphInstance(ticket, project);

    // Start instance
    await ralphService.startRalphInstance(instance.id);

    // Update ticket status
    await ticketsService.updateTicket(ticketId, { status: 'in_progress' });

    return c.json(instance, 201);
  } catch (error) {
    console.error('Failed to launch RALPH:', error);
    return c.json({ error: `Failed to launch RALPH: ${error}` }, 500);
  }
});

// GET /api/ralph/:id - Get instance status
app.get('/:id', async (c) => {
  const instance = await ralphService.getRalphInstance(c.req.param('id'));
  if (!instance) return c.json({ error: 'Instance not found' }, 404);
  return c.json(instance);
});

// GET /api/ralph/:id/logs - Get log contents
app.get('/:id/logs', async (c) => {
  const instance = await ralphService.getRalphInstance(c.req.param('id'));
  if (!instance) return c.json({ error: 'Instance not found' }, 404);
  if (!instance.logPath) return c.json({ error: 'No log file' }, 404);

  try {
    const logs = await readFile(instance.logPath, 'utf-8');
    return c.json({ logs });
  } catch {
    return c.json({ logs: '' });
  }
});

// POST /api/ralph/:id/stop - Stop running instance
app.post('/:id/stop', async (c) => {
  try {
    await ralphService.stopRalphInstance(c.req.param('id'));
    return c.json({ success: true });
  } catch (error) {
    return c.json({ error: `Failed to stop: ${error}` }, 500);
  }
});

// GET /api/tickets/:id/ralph - Get RALPH instance for ticket
app.get('/tickets/:id/ralph', async (c) => {
  const instance = await ralphService.getRalphInstanceForTicket(c.req.param('id'));
  if (!instance) return c.json({ error: 'No instance found' }, 404);
  return c.json(instance);
});

export default app;
```

**File:** `apps/server/src/index.ts` (update)
- Add: `import ralphRoutes from './routes/ralph';`
- Add: `app.route('/api/ralph', ralphRoutes);`
- Add: `app.route('/api', ralphRoutes);` (for /api/tickets/:id/launch-ralph)

**File:** `apps/server/src/routes/tickets.ts` (update)

Update the approve endpoint to launch RALPH:

```typescript
// POST /api/tickets/:id/approve - Approve PRD and launch RALPH
app.post('/:id/approve', async (c) => {
  const ticketId = c.req.param('id');
  const ticket = await ticketsService.getTicket(ticketId);

  if (!ticket) return c.json({ error: 'Ticket not found' }, 404);
  if (ticket.status !== 'in_review') {
    return c.json({ error: 'Ticket must be in review status' }, 400);
  }

  const project = await projectsService.getProject(ticket.projectId);
  if (!project) return c.json({ error: 'Project not found' }, 404);

  try {
    // Create and start RALPH instance
    const instance = await ralphService.createRalphInstance(ticket, project);
    await ralphService.startRalphInstance(instance.id);

    // Update ticket status
    const updatedTicket = await ticketsService.updateTicket(ticketId, {
      status: 'in_progress',
    });

    return c.json({ ticket: updatedTicket, instance });
  } catch (error) {
    console.error('Failed to launch RALPH:', error);
    return c.json({ error: `Failed to launch RALPH: ${error}` }, 500);
  }
});
```

**Acceptance Criteria:**
- [ ] RALPH instance created with worktree, PRD file, progress file, script
- [ ] RALPH script is executable and runs Claude Code
- [ ] Process spawned and PID tracked in database
- [ ] Logs written to file
- [ ] Can stop running instance
- [ ] Can get instance status
- [ ] Can get logs for instance
- [ ] Ticket status updates to 'in_progress' on launch

### 15. WebSocket Log Tailing

Implement real-time log streaming via WebSocket.

**File:** `apps/server/src/websocket.ts`

```typescript
import { watch } from 'fs';
import { readFile, stat } from 'fs/promises';
import type { ServerWebSocket } from 'bun';

interface WebSocketData {
  instanceId: string | null;
}

// Track subscriptions: instanceId -> Set of WebSockets
const subscriptions = new Map<string, Set<ServerWebSocket<WebSocketData>>>();

// Track file watchers
const fileWatchers = new Map<string, { watcher: ReturnType<typeof watch>; lastSize: number }>();

export const websocketHandler = {
  open(ws: ServerWebSocket<WebSocketData>) {
    ws.data = { instanceId: null };
    console.log('WebSocket connected');
  },

  async message(ws: ServerWebSocket<WebSocketData>, message: string) {
    try {
      const data = JSON.parse(message);

      if (data.type === 'subscribe' && data.instanceId) {
        await subscribeToLogs(ws, data.instanceId);
      } else if (data.type === 'unsubscribe') {
        unsubscribeFromLogs(ws);
      }
    } catch (error) {
      ws.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));
    }
  },

  close(ws: ServerWebSocket<WebSocketData>) {
    unsubscribeFromLogs(ws);
    console.log('WebSocket disconnected');
  },
};

async function subscribeToLogs(ws: ServerWebSocket<WebSocketData>, instanceId: string) {
  // Unsubscribe from previous
  unsubscribeFromLogs(ws);

  // Get instance to find log path
  const { getRalphInstance } = await import('./services/ralph');
  const instance = await getRalphInstance(instanceId);

  if (!instance || !instance.logPath) {
    ws.send(JSON.stringify({ type: 'error', message: 'Instance or log not found' }));
    return;
  }

  // Add to subscriptions
  ws.data.instanceId = instanceId;
  if (!subscriptions.has(instanceId)) {
    subscriptions.set(instanceId, new Set());
  }
  subscriptions.get(instanceId)!.add(ws);

  // Send current log content
  try {
    const content = await readFile(instance.logPath, 'utf-8');
    ws.send(JSON.stringify({ type: 'log', instanceId, data: content, initial: true }));
  } catch {
    ws.send(JSON.stringify({ type: 'log', instanceId, data: '', initial: true }));
  }

  // Start watching if not already
  if (!fileWatchers.has(instanceId)) {
    startWatching(instanceId, instance.logPath);
  }

  // Send current status
  ws.send(JSON.stringify({ type: 'status', instanceId, status: instance.status }));
}

function unsubscribeFromLogs(ws: ServerWebSocket<WebSocketData>) {
  const instanceId = ws.data.instanceId;
  if (!instanceId) return;

  const subs = subscriptions.get(instanceId);
  if (subs) {
    subs.delete(ws);
    if (subs.size === 0) {
      subscriptions.delete(instanceId);
      stopWatching(instanceId);
    }
  }
  ws.data.instanceId = null;
}

function startWatching(instanceId: string, logPath: string) {
  let lastSize = 0;

  // Get initial size
  stat(logPath).then(s => { lastSize = s.size; }).catch(() => {});

  const watcher = watch(logPath, async (eventType) => {
    if (eventType !== 'change') return;

    try {
      const stats = await stat(logPath);
      if (stats.size <= lastSize) return;

      // Read only new content
      const file = Bun.file(logPath);
      const content = await file.text();
      const newContent = content.slice(lastSize);
      lastSize = stats.size;

      // Broadcast to subscribers
      const subs = subscriptions.get(instanceId);
      if (subs) {
        const message = JSON.stringify({ type: 'log', instanceId, data: newContent });
        for (const ws of subs) {
          ws.send(message);
        }
      }
    } catch (error) {
      console.error('Error watching log file:', error);
    }
  });

  fileWatchers.set(instanceId, { watcher, lastSize });
}

function stopWatching(instanceId: string) {
  const watcherInfo = fileWatchers.get(instanceId);
  if (watcherInfo) {
    watcherInfo.watcher.close();
    fileWatchers.delete(instanceId);
  }
}

/**
 * Broadcast status change to all subscribers
 */
export function broadcastStatus(instanceId: string, status: string) {
  const subs = subscriptions.get(instanceId);
  if (subs) {
    const message = JSON.stringify({ type: 'status', instanceId, status });
    for (const ws of subs) {
      ws.send(message);
    }
  }
}
```

**File:** `apps/server/src/index.ts` (update)

Update to add WebSocket support:

```typescript
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { websocketHandler } from './websocket';
// ... other imports

const app = new Hono();
// ... existing setup

// Create Bun server with both HTTP and WebSocket
export default {
  port: 3001,
  fetch: app.fetch,
  websocket: websocketHandler,
};
```

**File:** `apps/web/src/hooks/useRalphLogs.ts`

```typescript
import { useState, useEffect, useRef, useCallback } from 'react';
import type { RalphStatus } from '@vibehq/shared';

interface UseRalphLogsResult {
  logs: string;
  status: RalphStatus | null;
  isConnected: boolean;
  error: string | null;
}

export function useRalphLogs(instanceId: string | null): UseRalphLogsResult {
  const [logs, setLogs] = useState('');
  const [status, setStatus] = useState<RalphStatus | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    if (!instanceId) {
      setLogs('');
      setStatus(null);
      return;
    }

    // Connect to WebSocket
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
    wsRef.current = ws;

    ws.onopen = () => {
      setIsConnected(true);
      setError(null);
      // Subscribe to instance
      ws.send(JSON.stringify({ type: 'subscribe', instanceId }));
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'log') {
        if (data.initial) {
          setLogs(data.data);
        } else {
          setLogs(prev => prev + data.data);
        }
      } else if (data.type === 'status') {
        setStatus(data.status);
      } else if (data.type === 'error') {
        setError(data.message);
      }
    };

    ws.onclose = () => {
      setIsConnected(false);
    };

    ws.onerror = () => {
      setError('WebSocket connection failed');
      setIsConnected(false);
    };

    return () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'unsubscribe' }));
      }
      ws.close();
    };
  }, [instanceId]);

  return { logs, status, isConnected, error };
}
```

**File:** `apps/web/src/components/RalphLogViewer.tsx`

```typescript
import { useEffect, useRef } from 'react';

interface RalphLogViewerProps {
  logs: string;
  status: string | null;
  isConnected: boolean;
}

export function RalphLogViewer({ logs, status, isConnected }: RalphLogViewerProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when logs update
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <div className="flex flex-col h-full">
      {/* Status bar */}
      <div className="flex items-center gap-2 px-3 py-2 bg-neutral-800 border-b border-neutral-700">
        <div className={`w-2 h-2 rounded-full ${
          isConnected ? 'bg-green-500' : 'bg-red-500'
        }`} />
        <span className="text-sm text-neutral-400">
          {isConnected ? 'Connected' : 'Disconnected'}
        </span>
        {status && (
          <span className={`ml-auto text-sm px-2 py-0.5 rounded ${
            status === 'running' ? 'bg-purple-500/20 text-purple-300' :
            status === 'completed' ? 'bg-green-500/20 text-green-300' :
            status === 'failed' ? 'bg-red-500/20 text-red-300' :
            'bg-neutral-500/20 text-neutral-300'
          }`}>
            {status}
          </span>
        )}
      </div>

      {/* Log content */}
      <div
        ref={containerRef}
        className="flex-1 overflow-auto p-4 font-mono text-sm bg-neutral-900 text-neutral-100 whitespace-pre-wrap"
      >
        {logs || 'Waiting for logs...'}
      </div>
    </div>
  );
}
```

**File:** `apps/web/src/components/TicketDetailPanel.tsx` (update)

Add log viewer for in_progress tickets:

```typescript
import { useRalphLogs } from '../hooks/useRalphLogs';
import { RalphLogViewer } from './RalphLogViewer';

// In component...
const { data: instance } = useQuery({
  queryKey: ['ralph-instance', ticket?.id],
  queryFn: () => api.get(`/tickets/${ticket!.id}/ralph`),
  enabled: ticket?.status === 'in_progress',
});

const { logs, status, isConnected } = useRalphLogs(instance?.id ?? null);

// In render...
{ticket.status === 'in_progress' && instance && (
  <div className="mt-4">
    <h3 className="text-lg font-semibold mb-2">RALPH Progress</h3>
    <div className="h-64 border border-neutral-700 rounded overflow-hidden">
      <RalphLogViewer logs={logs} status={status} isConnected={isConnected} />
    </div>
  </div>
)}
```

**File:** `apps/web/vite.config.ts` (update)

Add WebSocket proxy:

```typescript
export default defineConfig({
  // ... existing config
  server: {
    proxy: {
      '/api': 'http://localhost:3001',
      '/uploads': 'http://localhost:3001',
      '/ws': {
        target: 'ws://localhost:3001',
        ws: true,
      },
    },
  },
});
```

**Acceptance Criteria:**
- [ ] WebSocket connection established from frontend
- [ ] Can subscribe to instance logs
- [ ] Initial log content sent on subscribe
- [ ] New log content streamed in real-time
- [ ] Status changes broadcast to subscribers
- [ ] Multiple clients can watch same instance
- [ ] Connection cleanup on unmount
- [ ] Auto-scroll to bottom of logs
- [ ] Connection status indicator

### 16. Process Monitoring and Auto-Status Updates

Monitor RALPH processes and automatically update ticket status on completion.

**File:** `apps/server/src/services/process-monitor.ts`

```typescript
import { db, ralphInstances } from '../db';
import { eq } from 'drizzle-orm';
import { readFile } from 'fs/promises';
import { broadcastStatus } from '../websocket';
import * as ticketsService from './tickets';

let monitorInterval: Timer | null = null;
const POLL_INTERVAL = 5000; // 5 seconds

export function startProcessMonitor(): void {
  if (monitorInterval) return;
  console.log('Starting RALPH process monitor...');
  checkRunningInstances();
  monitorInterval = setInterval(checkRunningInstances, POLL_INTERVAL);
}

export function stopProcessMonitor(): void {
  if (monitorInterval) {
    clearInterval(monitorInterval);
    monitorInterval = null;
  }
}

async function checkRunningInstances(): Promise<void> {
  const runningInstances = await db.select()
    .from(ralphInstances)
    .where(eq(ralphInstances.status, 'running'));

  for (const instance of runningInstances) {
    if (!instance.pid) continue;

    const isRunning = isProcessRunning(instance.pid);
    if (!isRunning) {
      const status = await determineCompletionStatus(instance);

      await db.update(ralphInstances)
        .set({ status, completedAt: new Date() })
        .where(eq(ralphInstances.id, instance.id));

      const newTicketStatus = status === 'completed' ? 'in_testing' : 'in_review';
      await ticketsService.updateTicket(instance.ticketId, { status: newTicketStatus });

      broadcastStatus(instance.id, status);
      console.log(`RALPH ${instance.id} ${status}. Ticket → ${newTicketStatus}`);
    }
  }
}

function isProcessRunning(pid: number): boolean {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

async function determineCompletionStatus(instance: any): Promise<'completed' | 'failed'> {
  if (!instance.logPath) return 'failed';
  try {
    const log = await readFile(instance.logPath, 'utf-8');
    if (log.includes('RALPH_COMPLETE')) return 'completed';

    const errorPatterns = ['error:', 'Error:', 'fatal:', 'panic:', 'Traceback'];
    const lastChunk = log.slice(-2000);
    for (const pattern of errorPatterns) {
      if (lastChunk.includes(pattern)) return 'failed';
    }
    return 'completed';
  } catch {
    return 'failed';
  }
}

export async function recoverOrphanedInstances(): Promise<void> {
  const running = await db.select().from(ralphInstances).where(eq(ralphInstances.status, 'running'));
  for (const instance of running) {
    if (!instance.pid || !isProcessRunning(instance.pid)) {
      const status = await determineCompletionStatus(instance);
      await db.update(ralphInstances).set({ status, completedAt: new Date() }).where(eq(ralphInstances.id, instance.id));
      await ticketsService.updateTicket(instance.ticketId, { status: status === 'completed' ? 'in_testing' : 'in_review' });
    }
  }
}
```

**File:** `apps/server/src/index.ts` (update)

```typescript
import { startProcessMonitor, stopProcessMonitor, recoverOrphanedInstances } from './services/process-monitor';

// On startup
migrate();
await recoverOrphanedInstances();
startProcessMonitor();

// Graceful shutdown
process.on('SIGINT', () => { stopProcessMonitor(); process.exit(0); });
process.on('SIGTERM', () => { stopProcessMonitor(); process.exit(0); });
```

**Acceptance Criteria:**
- [ ] Process monitor polls every 5 seconds
- [ ] Completed RALPH moves ticket to 'in_testing'
- [ ] Failed RALPH moves ticket to 'in_review'
- [ ] Status changes broadcast via WebSocket
- [ ] Orphaned instances recovered on server restart
- [ ] Graceful shutdown stops monitor

---

### 17. Cleanup and Worktree Removal

Implement automatic cleanup after RALPH completion.

**File:** `apps/server/src/services/ralph.ts` (update)

Add cleanup function:

```typescript
import { rm } from 'fs/promises';
import * as worktreeService from './worktree';
import * as projectsService from './projects';

export async function cleanupRalphInstance(instanceId: string): Promise<void> {
  const instance = await getRalphInstance(instanceId);
  if (!instance) throw new Error('Instance not found');

  const ticket = await ticketsService.getTicket(instance.ticketId);
  if (!ticket) throw new Error('Ticket not found');

  const project = await projectsService.getProject(ticket.projectId);
  if (!project) throw new Error('Project not found');

  // Delete worktree (keeps branch for review)
  if (instance.worktreePath) {
    await worktreeService.deleteWorktree(
      project.path,
      instance.worktreePath,
      ticket.branchName || undefined,
      false // Don't delete branch yet
    );
  }

  // Note: We keep the database record for history
  // Branch can be deleted manually after merge
}

export async function cleanupAndDeleteBranch(instanceId: string): Promise<void> {
  const instance = await getRalphInstance(instanceId);
  if (!instance) throw new Error('Instance not found');

  const ticket = await ticketsService.getTicket(instance.ticketId);
  if (!ticket) throw new Error('Ticket not found');

  const project = await projectsService.getProject(ticket.projectId);
  if (!project) throw new Error('Project not found');

  if (instance.worktreePath && ticket.branchName) {
    await worktreeService.deleteWorktree(
      project.path,
      instance.worktreePath,
      ticket.branchName,
      true // Delete branch too
    );
  }
}
```

**File:** `apps/server/src/routes/ralph.ts` (update)

```typescript
// POST /api/ralph/:id/cleanup - Clean up instance files and worktree
app.post('/:id/cleanup', async (c) => {
  try {
    await ralphService.cleanupRalphInstance(c.req.param('id'));
    return c.json({ success: true });
  } catch (error) {
    return c.json({ error: `Cleanup failed: ${error}` }, 500);
  }
});

// POST /api/ralph/:id/cleanup-all - Clean up including branch deletion
app.post('/:id/cleanup-all', async (c) => {
  try {
    await ralphService.cleanupAndDeleteBranch(c.req.param('id'));
    return c.json({ success: true });
  } catch (error) {
    return c.json({ error: `Cleanup failed: ${error}` }, 500);
  }
});
```

**File:** `apps/web/src/components/TicketDetailPanel.tsx` (update)

For tickets in 'in_testing' status:

```typescript
{ticket.status === 'in_testing' && (
  <div className="space-y-4">
    <div className="flex items-center gap-2">
      <span className="text-sm text-neutral-400">Branch:</span>
      <code className="text-sm bg-neutral-800 px-2 py-1 rounded">{ticket.branchName}</code>
    </div>

    <div className="flex gap-2">
      <Button onClick={handleMarkComplete} variant="primary">
        Mark as Complete
      </Button>
      <Button onClick={handleCleanup} variant="secondary">
        Cleanup Worktree
      </Button>
    </div>

    <p className="text-xs text-neutral-500">
      Review the branch, merge if satisfied, then mark complete.
    </p>
  </div>
)}
```

**Mark Complete Flow:**
1. User reviews branch, tests changes
2. User merges branch (if satisfied)
3. Click "Mark Complete" → moves to 'completed' column
4. Optional: Click "Cleanup" to remove worktree (keeps branch for merge)

**Acceptance Criteria:**
- [ ] Worktree removed on cleanup
- [ ] Branch optionally deleted
- [ ] Database record preserved for history
- [ ] User can review branch before cleanup
- [ ] "Mark Complete" moves ticket to 'completed'
- [ ] Cleanup button visible for 'in_testing' tickets

---

### 18. Error Handling and Edge Cases

Implement robust error handling throughout the application.

**File:** `apps/server/src/middleware/error-handler.ts`

```typescript
import { Context, Next } from 'hono';

export async function errorHandler(c: Context, next: Next) {
  try {
    await next();
  } catch (error) {
    console.error('Unhandled error:', error);

    const message = error instanceof Error ? error.message : 'Internal server error';
    const status = (error as any).status || 500;

    return c.json({ error: message }, status);
  }
}
```

**File:** `apps/server/src/utils/errors.ts`

```typescript
export class NotFoundError extends Error {
  status = 404;
  constructor(message: string = 'Not found') {
    super(message);
  }
}

export class ValidationError extends Error {
  status = 400;
  constructor(message: string) {
    super(message);
  }
}

export class ConflictError extends Error {
  status = 409;
  constructor(message: string) {
    super(message);
  }
}
```

**File:** `apps/server/src/index.ts` (update)

```typescript
import { errorHandler } from './middleware/error-handler';

app.use('*', errorHandler);
```

**File:** `apps/web/src/components/Toast.tsx`

```typescript
import { useState, useEffect, createContext, useContext } from 'react';

interface Toast {
  id: string;
  type: 'success' | 'error' | 'info';
  message: string;
}

interface ToastContextValue {
  addToast: (type: Toast['type'], message: string) => void;
}

const ToastContext = createContext<ToastContextValue | null>(null);

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const addToast = (type: Toast['type'], message: string) => {
    const id = Math.random().toString(36).slice(2);
    setToasts(prev => [...prev, { id, type, message }]);

    // Auto-dismiss after 5 seconds
    setTimeout(() => {
      setToasts(prev => prev.filter(t => t.id !== id));
    }, 5000);
  };

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      <div className="fixed bottom-4 right-4 space-y-2 z-50">
        {toasts.map(toast => (
          <div
            key={toast.id}
            className={`px-4 py-3 rounded shadow-lg ${
              toast.type === 'success' ? 'bg-green-600' :
              toast.type === 'error' ? 'bg-red-600' :
              'bg-blue-600'
            } text-white`}
          >
            {toast.message}
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) throw new Error('useToast must be used within ToastProvider');
  return context;
}
```

**File:** `apps/web/src/components/ErrorBoundary.tsx`

```typescript
import { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('React error boundary caught:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-8 text-center">
          <h2 className="text-xl font-bold text-red-400 mb-2">Something went wrong</h2>
          <p className="text-neutral-400 mb-4">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false })}
            className="px-4 py-2 bg-neutral-700 rounded hover:bg-neutral-600"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**File:** `apps/web/src/main.tsx` (update)

```typescript
import { ErrorBoundary } from './components/ErrorBoundary';
import { ToastProvider } from './components/Toast';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ToastProvider>
          <BrowserRouter>
            <App />
          </BrowserRouter>
        </ToastProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  </React.StrictMode>
);
```

**Edge Cases to Handle:**

1. **Project path validation:**
   - Check path exists before saving project
   - Check path is a git repo
   - Show warning if path doesn't exist

2. **Claude Code availability:**
   - Check if `claude` command exists before PRD generation
   - Provide helpful error message if not installed

3. **Concurrent access:**
   - SQLite WAL mode handles multiple readers
   - Use transactions for multi-row updates

4. **WebSocket reconnection:**
   - Implement reconnection logic in useRalphLogs
   - Exponential backoff

5. **File system errors:**
   - Handle missing log files gracefully
   - Handle permission errors

**Acceptance Criteria:**
- [ ] API errors return consistent JSON format
- [ ] Frontend shows toast notifications for errors
- [ ] Error boundary catches React crashes
- [ ] Project path validated on create/update
- [ ] Claude Code availability checked before PRD generation
- [ ] WebSocket reconnects on disconnect
- [ ] File system errors handled gracefully

---

## Quality Requirements

- All code must pass TypeScript type checking (`bun run typecheck`)
- All code must pass linting (`bun run lint`)
- Use consistent code style (Prettier)
- No `any` types except where absolutely necessary
- All API endpoints must have proper error handling
- All database operations must handle errors
- Frontend must have loading states for async operations
- Use optimistic updates where appropriate for better UX

---

## Priority Order

1. Project Scaffolding - Foundation, everything depends on it
2. Database Schema - Core data model needed for all features
3. Backend API - Projects - Proves stack works, simple CRUD
4. Backend API - Tickets - Core data for kanban
5. Frontend Shell - Basic app structure
6. Projects UI - First full vertical slice
7. Kanban Board Layout - Core visual experience
8. Drag and Drop - Key UX feature
9. Ticket Detail Panel - Needed before images/PRD
10. Image Upload - Supports PRD generation context
11. PRD Generation - Core RALPH integration
12. PRD Review UI - Approve flow
13. Git Worktree Management - Needed for parallel execution
14. RALPH Instance Management - Core execution logic
15. WebSocket Log Tailing - Real-time feedback
16. Process Monitoring - Auto-status updates
17. Cleanup - Proper resource management
18. Error Handling - Production readiness

---

## Notes

- This is a local-only application, no authentication needed
- All paths are local filesystem paths
- Claude Code CLI must be installed and in PATH
- Git must be installed and repositories must be initialized
- SQLite database stored in `apps/server/data/`
- Uploaded images stored in `apps/server/data/uploads/`
- RALPH instances create worktrees in project's `.ralph-worktrees/` directory

---

## File Structure Summary

```
vibehq/
├── package.json
├── tsconfig.base.json
├── .gitignore
├── apps/
│   ├── web/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── vite.config.ts
│   │   ├── tailwind.config.js
│   │   ├── postcss.config.js
│   │   ├── index.html
│   │   └── src/
│   │       ├── main.tsx
│   │       ├── App.tsx
│   │       ├── index.css
│   │       ├── lib/
│   │       │   └── api.ts
│   │       ├── hooks/
│   │       │   ├── useProjects.ts
│   │       │   ├── useTickets.ts
│   │       │   ├── useImages.ts
│   │       │   └── useRalphLogs.ts
│   │       ├── pages/
│   │       │   ├── DashboardPage.tsx
│   │       │   └── ProjectsPage.tsx
│   │       └── components/
│   │           ├── Layout.tsx
│   │           ├── KanbanBoard.tsx
│   │           ├── KanbanColumn.tsx
│   │           ├── TicketCard.tsx
│   │           ├── SortableTicketCard.tsx
│   │           ├── TicketDetailPanel.tsx
│   │           ├── TicketForm.tsx
│   │           ├── NewTicketModal.tsx
│   │           ├── ProjectModal.tsx
│   │           ├── ConfirmDialog.tsx
│   │           ├── ImageUpload.tsx
│   │           ├── PRDViewer.tsx
│   │           ├── PRDEditor.tsx
│   │           ├── RalphLogViewer.tsx
│   │           ├── ErrorBoundary.tsx
│   │           └── Toast.tsx
│   └── server/
│       ├── package.json
│       ├── tsconfig.json
│       └── src/
│           ├── index.ts
│           ├── websocket.ts
│           ├── db/
│           │   ├── index.ts
│           │   ├── schema.ts
│           │   └── migrate.ts
│           ├── services/
│           │   ├── projects.ts
│           │   ├── tickets.ts
│           │   ├── images.ts
│           │   ├── prd-generator.ts
│           │   ├── worktree.ts
│           │   ├── ralph.ts
│           │   └── process-monitor.ts
│           ├── routes/
│           │   ├── projects.ts
│           │   ├── tickets.ts
│           │   ├── images.ts
│           │   ├── ralph.ts
│           │   └── static.ts
│           ├── middleware/
│           │   └── error-handler.ts
│           └── utils/
│               ├── shell.ts
│               └── errors.ts
└── packages/
    └── shared/
        ├── package.json
        ├── tsconfig.json
        └── src/
            ├── index.ts
            └── types.ts
```
